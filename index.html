<!DOCTYPE html>
<html>
<head>
    <title>Claim Your Coupon</title>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial; }
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .container { background: white; border-radius: 20px; padding: 40px; max-width: 500px; width: 100%; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .success { color: #2E7D32; }
        .blocked { color: #C62828; }
        .coupon { font-size: 48px; font-weight: bold; color: #D32F2F; margin: 20px 0; font-family: 'Courier New', monospace; background: #f5f5f5; padding: 15px; border-radius: 10px; border: 2px dashed #D32F2F; }
        .info { background: #E3F2FD; padding: 15px; border-radius: 10px; margin: 20px 0; font-size: 14px; }
        .countdown { font-size: 24px; font-weight: bold; color: #E65100; margin: 20px 0; }
        .loading { text-align: center; padding: 40px; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Loading -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Loading your coupon...</p>
        </div>
        
        <!-- Success -->
        <div id="success" class="hidden">
            <h1 class="success">‚úÖ Coupon Claimed!</h1>
            <h2 id="adName"></h2>
            <p>Location: <span id="hostName"></span></p>
            
            <div class="coupon" id="couponCode"></div>
            <p>Show this code at checkout</p>
            
            <div class="info">
                <p><strong>‚úÖ Valid:</strong> 24 hours from now</p>
                <p><strong>‚ö†Ô∏è Limit:</strong> 1 coupon per ad per day (any location)</p>
                <p><strong>üïí Claimed at:</strong> <span id="claimTime"></span></p>
                <p><strong>üìç Location:</strong> <span id="locationName"></span></p>
            </div>
            
            <div class="info" style="background: #FFF3E0;">
                <p><strong>Note:</strong> You cannot claim <strong>this same ad</strong> at any other location today.</p>
                <p>You CAN claim <strong>different ads</strong> at any location.</p>
            </div>
            
            <p style="color: #FF9800; font-weight: bold; margin-top: 20px;">
                ‚ö†Ô∏è Do not refresh this page
            </p>
        </div>
        
        <!-- Blocked -->
        <div id="blocked" class="hidden">
            <h1 class="blocked">‚õî Already Claimed</h1>
            <h3 id="blockedAdName"></h3>
            
            <div class="info" style="background: #FFEBEE;">
                <p>You've already claimed <strong>this ad</strong> today.</p>
                <p><strong>Location:</strong> <span id="blockedLocation"></span></p>
                <p><strong>Time:</strong> <span id="blockedTime"></span></p>
            </div>
            
            <div class="countdown" id="countdown"></div>
            
            <div class="info">
                <p><strong>You can still claim:</strong></p>
                <p>‚úÖ <strong>Different ads</strong> at any location</p>
                <p>‚ùå <strong>This same ad</strong> at any location (until tomorrow)</p>
            </div>
        </div>
        
        <!-- Error -->
        <div id="error" class="hidden">
            <h1 style="color: #FF5722;">‚ùå Error</h1>
            <p id="errorMessage"></p>
            <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">
                Try Again
            </button>
        </div>
    </div>

   <script>
    // === CONFIGURATION ===
    const CONFIG = {
        BLOCK_HOURS: 24,
        MAX_CLAIMS_PER_AD_PER_DAY: 1
    };

    // === FIREBASE CONFIG ===
    const firebaseConfig = {
        apiKey: "AIzaSyCxuGBz5FNcaXbCNOfoC9ccR5IsZSYS1d4",
        authDomain: "ad-coupon-system.firebaseapp.com",
        projectId: "ad-coupon-system",
        storageBucket: "ad-coupon-system.firebasestorage.app",
        messagingSenderId: "1030272051491",
        appId: "1:1030272051491:web:4ec6ce21336cf511cac496",
        measurementId: "G-PR9E37ZYE2"
    };
    
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    
    // Global variables
    let currentUser = null;
    let currentAd = null;
    let currentHost = null;
    let userFingerprint = null;
    
    // === TIME PROTECTION SYSTEM ===
    const TimeGuard = {
        // Store server time to detect clock changes
        serverTimeOffset: 0,
        
        // Get current REAL time (immune to system clock changes)
        getRealTime: function() {
            return Date.now() + this.serverTimeOffset;
        },
        
        // Fetch server time to detect clock tampering
        syncServerTime: async function() {
            try {
                const start = Date.now();
                // Use multiple time sources
                const timeSources = [
                    'https://worldtimeapi.org/api/timezone/Etc/UTC',
                    'https://timeapi.io/api/Time/current/zone?timeZone=UTC',
                    'https://www.timeapi.io/api/Time/current/zone?timeZone=UTC'
                ];
                
                for (const source of timeSources) {
                    try {
                        const response = await fetch(source, { 
                            signal: AbortSignal.timeout(3000) 
                        });
                        const data = await response.json();
                        const serverTime = new Date(data.utcDateTime || data.currentDateTime || data.datetime).getTime();
                        const clientTime = Date.now();
                        const roundTrip = Date.now() - start;
                        
                        // Calculate offset (accounting for network delay)
                        this.serverTimeOffset = serverTime - clientTime + (roundTrip / 2);
                        
                        // Store for later verification
                        localStorage.setItem('time_offset', this.serverTimeOffset.toString());
                        localStorage.setItem('time_synced', Date.now().toString());
                        
                        return true;
                    } catch (e) {
                        continue;
                    }
                }
                return false;
            } catch (error) {
                return false;
            }
        },
        
        // Check if user changed their clock
        detectClockTampering: function() {
            const lastSync = parseInt(localStorage.getItem('time_synced') || '0');
            const storedOffset = parseFloat(localStorage.getItem('time_offset') || '0');
            
            if (Date.now() - lastSync > 3600000) { // Older than 1 hour
                return false; // Need fresh sync
            }
            
            // Check if current offset differs significantly from stored
            const currentOffset = this.serverTimeOffset;
            const diff = Math.abs(currentOffset - storedOffset);
            
            // If difference > 5 minutes, likely clock tampering
            if (diff > 300000) {
                console.warn('Clock tampering detected! Offset diff:', diff);
                return true;
            }
            
            return false;
        },
        
        // Get 24 hours ago in REAL time
        get24HoursAgo: function() {
            return new Date(this.getRealTime() - (24 * 60 * 60 * 1000));
        }
    };
    
    // === STORAGE PROTECTION ===
    const SecureStorage = {
        // Encrypt data before storing
        encrypt: function(text, key = 'coupon_system_2024') {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                result += String.fromCharCode(charCode);
            }
            return btoa(result);
        },
        
        decrypt: function(encrypted, key = 'coupon_system_2024') {
            try {
                const text = atob(encrypted);
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode);
                }
                return result;
            } catch (e) {
                return null;
            }
        },
        
        // Store with multiple layers
        setClaim: function(adId, fingerprint, data) {
            const key = `claim_${adId}_${fingerprint}`;
            const encrypted = this.encrypt(JSON.stringify({
                ...data,
                _timestamp: TimeGuard.getRealTime(),
                _hash: this.hash(JSON.stringify(data) + TimeGuard.getRealTime())
            }));
            
            // Store in multiple places
            localStorage.setItem(key, encrypted);
            sessionStorage.setItem(key, encrypted);
            
            // Also store in IndexedDB (harder to clear)
            this.storeInIndexedDB(key, encrypted);
            
            // Store verification signature
            const verifyKey = `v_${key}`;
            localStorage.setItem(verifyKey, this.hash(encrypted + TimeGuard.getRealTime()));
        },
        
        getClaim: function(adId, fingerprint) {
            const key = `claim_${adId}_${fingerprint}`;
            const verifyKey = `v_${key}`;
            
            // Check verification first
            const encrypted = localStorage.getItem(key);
            const verification = localStorage.getItem(verifyKey);
            
            if (!encrypted || !verification) return null;
            
            // Verify integrity
            if (verification !== this.hash(encrypted + TimeGuard.getRealTime())) {
                console.warn('Tampered claim data detected');
                return null;
            }
            
            const decrypted = this.decrypt(encrypted);
            if (!decrypted) return null;
            
            try {
                const data = JSON.parse(decrypted);
                // Verify hash
                if (data._hash !== this.hash(JSON.stringify({
                    coupon: data.coupon,
                    time: data.time,
                    expires: data.expires
                }) + data._timestamp)) {
                    return null;
                }
                return data;
            } catch (e) {
                return null;
            }
        },
        
        hash: function(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & hash;
            }
            return Math.abs(hash).toString(36);
        },
        
        storeInIndexedDB: function(key, value) {
            if (!window.indexedDB) return;
            
            try {
                const request = indexedDB.open('CouponDB', 1);
                request.onupgradeneeded = function(e) {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('claims')) {
                        db.createObjectStore('claims', { keyPath: 'key' });
                    }
                };
                request.onsuccess = function(e) {
                    const db = e.target.result;
                    const transaction = db.transaction(['claims'], 'readwrite');
                    const store = transaction.objectStore('claims');
                    store.put({ key: key, value: value, timestamp: Date.now() });
                };
            } catch (e) {
                // Silent fail
            }
        }
    };
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async function() {
        try {
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            currentAd = urlParams.get('ad') || 'unknown_ad';
            currentHost = urlParams.get('host') || 'unknown_location';
            
            // Decode ad name for display
            const displayAdName = decodeURIComponent(currentAd).replace(/_/g, ' ');
            const displayHostName = decodeURIComponent(currentHost).replace(/_/g, ' ');
            
            document.getElementById('adName').textContent = displayAdName;
            document.getElementById('hostName').textContent = displayHostName;
            document.getElementById('locationName').textContent = displayHostName;
            document.getElementById('blockedAdName').textContent = displayAdName;
            document.getElementById('blockedLocation').textContent = displayHostName;
            
            // Initialize Firebase Auth (anonymous)
            const userCredential = await auth.signInAnonymously();
            currentUser = userCredential.user;
            
            // Generate user fingerprint
            userFingerprint = await generateUserFingerprint();
            
            // Sync time with server to prevent clock cheating
            await TimeGuard.syncServerTime();
            
            // Check for clock tampering
            if (TimeGuard.detectClockTampering()) {
                showError('System clock inconsistency detected. Please check your system time.');
                return;
            }
            
            // Check if user already claimed this ad TODAY
            await checkIfAlreadyClaimed();
            
        } catch (error) {
            showError('Initialization error: ' + error.message);
        }
    });
    
    // === CORE LOGIC WITH CLOCK PROTECTION ===
    async function checkIfAlreadyClaimed() {
        try {
            // 1. Check secure local storage (with REAL time check)
            const storedClaim = SecureStorage.getClaim(currentAd, userFingerprint);
            if (storedClaim) {
                const claimTime = new Date(storedClaim.time);
                const twentyFourHoursAgo = TimeGuard.get24HoursAgo();
                
                if (claimTime >= twentyFourHoursAgo) {
                    showBlockedPage({
                        claimedAt: { toDate: () => claimTime },
                        hostName: storedClaim.hostName || 'Unknown'
                    });
                    return true;
                }
            }
            
            // 2. Check Firestore (server time - can't be faked)
            const firestoreBlocked = await checkFirestoreClaims();
            if (firestoreBlocked.blocked) {
                showBlockedPage(firestoreBlocked.data);
                
                // Store in secure storage
                if (firestoreBlocked.data) {
                    SecureStorage.setClaim(currentAd, userFingerprint, {
                        coupon: firestoreBlocked.data.couponCode,
                        time: firestoreBlocked.data.claimedAt?.toDate() || new Date(),
                        expires: firestoreBlocked.data.expiresAt,
                        hostName: firestoreBlocked.data.hostName
                    });
                }
                return true;
            }
            
            // 3. Generate new coupon
            await generateNewCoupon();
            return false;
            
        } catch (error) {
            console.error("Check error:", error);
            showError('Verification error: ' + error.message);
            return false;
        }
    }
    
    async function checkFirestoreClaims() {
        try {
            // Use REAL time for calculation
            const twentyFourHoursAgo = TimeGuard.get24HoursAgo();
            
            const claimsSnapshot = await db.collection('claims')
                .where('userFingerprint', '==', userFingerprint)
                .where('adId', '==', currentAd)
                .orderBy('claimedAt', 'desc')
                .limit(1)
                .get();
            
            if (!claimsSnapshot.empty) {
                const claim = claimsSnapshot.docs[0].data();
                const claimTime = claim.claimedAt?.toDate();
                
                // Compare with REAL time
                if (claimTime >= twentyFourHoursAgo) {
                    return { blocked: true, data: claim };
                }
            }
            
            return { blocked: false, data: null };
            
        } catch (error) {
            console.error('Firestore check error:', error);
            return { blocked: false, data: null };
        }
    }
    
    async function generateNewCoupon() {
        try {
            // Generate unique coupon code
            const couponCode = 'SAVE' + 
                Math.floor(Math.random() * 9000 + 1000) + 
                String.fromCharCode(65 + Math.floor(Math.random() * 26));
            
            // Get client IP
            const clientIP = await getClientIP();
            
            // Prepare claim data with REAL timestamp
            const claimData = {
                userId: currentUser.uid,
                userFingerprint: userFingerprint,
                userIP: clientIP,
                adId: currentAd,
                adName: decodeURIComponent(currentAd).replace(/_/g, ' '),
                hostId: currentHost,
                hostName: decodeURIComponent(currentHost).replace(/_/g, ' '),
                couponCode: couponCode,
                claimedAt: firebase.firestore.FieldValue.serverTimestamp(), // SERVER TIME!
                expiresAt: new Date(TimeGuard.getRealTime() + (CONFIG.BLOCK_HOURS * 60 * 60 * 1000)),
                clientIP: clientIP,
                userAgent: navigator.userAgent,
                status: 'active'
            };
            
            // Save to Firestore (server time - can't be faked)
            await db.collection('claims').add(claimData);
            
            // Store in secure local storage
            SecureStorage.setClaim(currentAd, userFingerprint, {
                coupon: couponCode,
                time: new Date(TimeGuard.getRealTime()), // REAL time
                expires: claimData.expiresAt,
                hostName: claimData.hostName
            });
            
            // Show success page
            showSuccessPage(claimData);
            
            // Setup refresh protection
            setupRefreshProtection();
            
        } catch (error) {
            showError('Failed to generate coupon: ' + error.message);
        }
    }
    
    // === UTILITY FUNCTIONS ===
    async function generateUserFingerprint() {
        try {
            const clientIP = await getClientIP();
            const fingerprintData = {
                ip: clientIP,
                userAgent: navigator.userAgent,
                language: navigator.language,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                screen: `${screen.width}x${screen.height}`,
                cookiesEnabled: navigator.cookieEnabled
            };
            
            const dataString = JSON.stringify(fingerprintData);
            let hash = 0;
            for (let i = 0; i < dataString.length; i++) {
                const char = dataString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            
            return `fp_${Math.abs(hash).toString(36)}`;
            
        } catch (error) {
            return `fallback_${navigator.userAgent.substring(0, 50)}_${navigator.language}`;
        }
    }
    
    async function getClientIP() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            return data.ip;
        } catch (error) {
            return 'unknown';
        }
    }
    
    // === UI FUNCTIONS ===
    function showSuccessPage(data) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('success').classList.remove('hidden');
        document.getElementById('blocked').classList.add('hidden');
        document.getElementById('error').classList.add('hidden');
        
        document.getElementById('couponCode').textContent = data.couponCode;
        document.getElementById('claimTime').textContent = new Date().toLocaleTimeString();
        
        // Add copy functionality
        addCopyFunctionality(data.couponCode);
    }
    
    function showBlockedPage(existingClaim) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('success').classList.add('hidden');
        document.getElementById('blocked').classList.remove('hidden');
        document.getElementById('error').classList.add('hidden');
        
        const claimedTime = existingClaim.claimedAt?.toDate() || new Date();
        document.getElementById('blockedTime').textContent = claimedTime.toLocaleTimeString();
        
        // Calculate next available time using REAL time
        const nextAvailable = new Date(claimedTime.getTime() + (24 * 60 * 60 * 1000));
        startCountdown(nextAvailable);
    }
    
    function showError(message) {
        document.getElementById('loading').classList.add('hidden');
        document.getElementById('success').classList.add('hidden');
        document.getElementById('blocked').classList.add('hidden');
        document.getElementById('error').classList.remove('hidden');
        document.getElementById('errorMessage').textContent = message;
    }
    
    function startCountdown(targetTime) {
        function updateCountdown() {
            const now = new Date();
            const diff = targetTime - now;
            
            if (diff <= 0) {
                document.getElementById('countdown').innerHTML = 
                    '<span style="color: #4CAF50;">‚úÖ Ready to claim again!</span>';
                return;
            }
            
            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            
            document.getElementById('countdown').innerHTML = 
                `<div style="font-size: 28px;">
                    ${hours.toString().padStart(2, '0')}:
                    ${minutes.toString().padStart(2, '0')}:
                    ${seconds.toString().padStart(2, '0')}
                </div>`;
            
            setTimeout(updateCountdown, 1000);
        }
        
        updateCountdown();
    }
    
    function addCopyFunctionality(couponCode) {
        const couponElement = document.getElementById('couponCode');
        couponElement.style.cursor = 'pointer';
        couponElement.title = 'Click to copy';
        
        couponElement.onclick = function() {
            navigator.clipboard.writeText(couponCode).then(() => {
                const originalText = couponElement.textContent;
                couponElement.textContent = '‚úÖ Copied!';
                couponElement.style.color = '#4CAF50';
                
                setTimeout(() => {
                    couponElement.textContent = originalText;
                    couponElement.style.color = '#D32F2F';
                }, 2000);
            });
        };
    }
    
    function setupRefreshProtection() {
        const newUrl = window.location.origin + window.location.pathname + 
            '?ad=' + encodeURIComponent(currentAd) + 
            '&host=' + encodeURIComponent(currentHost) + 
            '&claimed=true&t=' + Date.now();
        history.replaceState(null, null, newUrl);
        
        window.onbeforeunload = function() {
            return "Your coupon has been saved. Do not refresh or you'll lose it!";
        };
        
        if (performance.navigation.type === 1) {
            const stored = SecureStorage.getClaim(currentAd, userFingerprint);
            if (stored) {
                const mockClaim = {
                    claimedAt: { toDate: () => new Date(stored.time) },
                    hostName: stored.hostName
                };
                showBlockedPage(mockClaim);
                return;
            }
        }
    }
    
    // Periodically verify time sync
    setInterval(async () => {
        await TimeGuard.syncServerTime();
        if (TimeGuard.detectClockTampering()) {
            console.warn('Clock tampering detected during session');
        }
    }, 30 * 60 * 1000); // Every 30 minutes
</script>
</body>
</html>